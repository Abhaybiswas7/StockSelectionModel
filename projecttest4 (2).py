# -*- coding: utf-8 -*-
"""projecttest4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H5tLF-lI8uQRMcD2csqy4eMFq4yvnXy9
"""

!pip install mplfinance
!pip install plotly
!pip install ipywidgets

!pip install yfinance matplotlib ipywidgets
import pandas as pd
from nltk.sentiment import SentimentIntensityAnalyzer
import matplotlib.pyplot as plt
from bs4 import BeautifulSoup
from urllib.request import urlopen, Request
import datetime
import re
from datetime import datetime, timedelta
import nltk
nltk.download('vader_lexicon') #sentiment analyser
import yfinance as yf
import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import display
import mplfinance as mpf

Finviz_url = 'https://finviz.com/quote.ashx?t='

#Enter ticker values here

tickers = ['TSLA', 'META', 'RDDT','AAL', 'NVDA','GOOG','AMD']
news_tables = {}

for ticker in tickers:
    url = Finviz_url + ticker
    req = Request(url=url, headers={'user-agent': 'my-app'})
    response = urlopen(req)
    html = BeautifulSoup(response, 'html.parser')
    news_table = html.find(id='news-table')
    news_tables[ticker] = news_table
# Parsing data with date and time handling
parsed_data = []
for ticker, news_table in news_tables.items():
    rows = news_table.findAll('tr')
    current_date = None  # Variable to keep track of the most recent date

    for row in rows:
        a_tag = row.a
        title = a_tag.get_text().strip() if a_tag else "No Title"

        td_text = row.td.text.strip() if row.td else ""
        date_data = td_text.split(' ')

        if len(date_data) == 1:  # Only time is present
            time = date_data[0]
        else:  # Date and time are present
            current_date = date_data[0]  # Update the most recent date
            time = date_data[1]

        if current_date:  # Only append data if a date is present
            parsed_data.append([ticker, current_date, time, title])

# Convert to DataFrame
df = pd.DataFrame(parsed_data, columns=['ticker', 'date', 'time', 'title'])



# First, get today's date
today = datetime.now().date()

#process your parsed_data to replace 'Today' and 'Yesterday' with actual dates
for i, row in enumerate(parsed_data):
    if row[1] == 'Today':
        parsed_data[i][1] = today
    elif row[1] == 'Yesterday':
        parsed_data[i][1] = today - timedelta(days=1)

df = pd.DataFrame(parsed_data, columns=['ticker', 'date', 'time', 'title'])
vader = SentimentIntensityAnalyzer()

f = lambda title: vader.polarity_scores(title)['compound'] #to find just compound value for the title
df['compound'] = df['title'].apply(f) #apply to all titles, meaning only compound for all titles

df['date'] = pd.to_datetime(df.date).dt.date #changes date from string to datetime format,so that it is ordered by date


plt.figure(figsize=(10,8)) #to visualise
print(df.head(10))

import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime



# To Ensure 'compound' is numeric
df['compound'] = pd.to_numeric(df['compound'], errors='coerce')

# Calculate mean sentiment score by ticker and date
mean_df = df.groupby(['ticker', 'date'])['compound'].mean().unstack()

# Calculate the overall mean sentiment score for each ticker across all dates
overall_mean_df = df.groupby('ticker')['compound'].mean()

# Determine the timeframe from the DataFrame
timeframe_min = df['date'].min()
timeframe_max = df['date'].max()

# Plot the overall average sentiment for each ticker
overall_mean_df.plot(kind='bar', figsize=(10, 6))

# Formatting the title with timeframe
plt.title(f'Overall Average Sentiment Score by Ticker from {timeframe_min} to {timeframe_max}')
plt.ylabel('Average Compound Score')
plt.xlabel('Ticker')
plt.xticks(rotation=45)  # Adjust for readability if necessary

plt.tight_layout()
plt.show()

#compare todays compouds to the avg compound

# Determine the current date (you can adjust this to your specific requirements)
current_date = datetime.now().date()

# Calculate the overall mean compound score for each ticker
overall_mean_df = df.groupby('ticker')['compound'].mean()

# Filter out only today's data and then calculate the mean
todays_data = df[df['date'] == current_date]
todays_mean_df = todays_data.groupby('ticker')['compound'].mean()

# Determine the timeframe from the DataFrame
timeframe = df['date'].agg(['min', 'max'])

# Plotting
fig, ax = plt.subplots(figsize=(10, 7))

# Plot the overall average compound score for each ticker
overall_mean_df.plot(kind='bar', ax=ax, position=0, width=0.2, color='blue', alpha=0.6, label='Overall Average')

# Plot today's average compound score for each ticker
todays_mean_df.plot(kind='bar', ax=ax, position=1, width=0.2, color='green', alpha=0.6, label=f"Average for {current_date}")

# Set the title to include the timeframe
ax.set_title(f'Overall Average and {current_date} Sentiment Score by Ticker\nData from {timeframe["min"]} to {timeframe["max"]}')
ax.set_ylabel('Average Compound Score')
ax.set_xlabel('Ticker')
ax.legend()

plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Ensuring the 'date' column is in the correct datetime format
df['date'] = pd.to_datetime(df['date']).dt.date

# Today's date
today = datetime.now().date()

# Calculate the overall mean compound score for each ticker
overall_mean = df.groupby('ticker')['compound'].mean().reset_index(name='Overall Avg')

# Filter today's data and calculate the mean compound score
todays_data = df[df['date'] == today]
todays_mean = todays_data.groupby('ticker')['compound'].mean().reset_index(name='Today\'s Avg')

# Merge the overall average with today's average
comparison_table = pd.merge(overall_mean, todays_mean, on='ticker', how='outer')

# If there are any NaN values
comparison_table.fillna('N/A', inplace=True)

# Display the table
print(comparison_table)

# Define a threshold for significant difference

significant_difference_threshold = 0.05

def determine_sentiment_adjusted(row):
    # Check if today's average is 'N/A'
    if isinstance(row['Today\'s Avg'], str) and row['Today\'s Avg'].upper() == 'N/A':
        # Determine sentiment based on overall average
        if row['Overall Avg'] > 0:
            return 'Bullish Sentiment (Based on Overall Avg)'
        elif row['Overall Avg'] < 0:
            return 'Bearish Sentiment (Based on Overall Avg)'
        else:
            return 'Neutral Sentiment (Based on Overall Avg)'

    # If today's average is 0, determine inference from overall average
    elif row['Today\'s Avg'] == 0:
        if row['Overall Avg'] > 0:
            return 'Bullish Sentiment (Based on Overall Avg)'
        elif row['Overall Avg'] < 0:
            return 'Bearish Sentiment (Based on Overall Avg)'
        else:
            return 'Neutral Sentiment (Based on Overall Avg)'

    # Handle non-zero today's average with comparison to overall average
    elif row['Today\'s Avg'] > row['Overall Avg']:
        # Check if the difference is significant
        if row['Today\'s Avg'] - row['Overall Avg'] > significant_difference_threshold:
            return 'Bullish Sentiment'
        else:
            return 'Neutral / Slightly Bullish'
    else:
        # Check if the difference is significant
        if row['Overall Avg'] - row['Today\'s Avg'] > significant_difference_threshold:
            return 'Bearish Sentiment'
        else:
            return 'Neutral / Slightly Bearish'

# Ensuring to convert 'Today\'s Avg' to numeric values where possible to handle comparisons correctly
comparison_table['Today\'s Avg'] = pd.to_numeric(comparison_table['Today\'s Avg'], errors='coerce')

# Apply the adjusted function across the DataFrame rows
comparison_table['Inference'] = comparison_table.apply(determine_sentiment_adjusted, axis=1)
print(comparison_table)

!pip install tiingo
from tiingo import TiingoClient
!pip install tiingo[pandas]

# Set up Tiingo API key and client
config = {'api_key': 'fb3633770ff0c0a353940647ea3df27c8b29f9a3'}
client = TiingoClient(config)


def fetch_intraday_data_tiingo(ticker):
    # Calculate the date 60 days ago from the current date
    sixty_days_ago = (datetime.now() - timedelta(days=60)).strftime('%Y-%m-%d')
    current_date = datetime.now().strftime('%Y-%m-%d')

    # Fetch 15-minute interval stock data from Tiingo for the last 60 days
    historical_prices = client.get_dataframe(ticker,
                                             frequency='15min',
                                             startDate=sixty_days_ago,
                                             endDate=current_date)  # You can also omit this for the current date

    # The TiingoClient already returns a DataFrame, but you may want to ensure the datetime is set as the index
    historical_prices.index = pd.to_datetime(historical_prices.index)

    return historical_prices

def plot_candlestick(ticker):
    df = fetch_intraday_data_tiingo(ticker)

    if df.empty:
        print(f"No data returned for {ticker}.")
        return

    # Calculate 21-period EMA and 50-period EMA
    df['21_EMA'] = df['close'].ewm(span=21, adjust=False).mean()
    df['50_EMA'] = df['close'].ewm(span=50, adjust=False).mean()

    # MPLFinance plot settings
    mpf_plot_kwargs = {
        'type': 'candle',
        'mav': (21, 50),
        'figratio': (30, 15),
        'title': f'{ticker} 15m Candlestick Chart with 21 EMA and 50 EMA',
        'style': 'yahoo'
    }

    # Plotting the candlestick chart
    mpf.plot(df, **mpf_plot_kwargs)

# Dropdown widget for ticker selection
# Check if 'tickers' list is not empty to avoid errors
if tickers:
    default_value = tickers[0]  # Set default value to the first item in the list
else:
    default_value = None  # No default value if list is empty

ticker_dropdown = widgets.Dropdown(
    options=tickers,  # Dynamically set options from the 'tickers' variable
    value=default_value,  # Dynamically set default value
    description='Ticker:'


)

# Observe changes in the dropdown and update the chart accordingly
def on_ticker_change(change):
    if change['type'] == 'change' and change['name'] == 'value':
        plot_candlestick(change['new'])

ticker_dropdown.observe(on_ticker_change, names='value')

# Display the dropdown and plot the initial ticker
display(ticker_dropdown)
plot_candlestick(ticker_dropdown.value)